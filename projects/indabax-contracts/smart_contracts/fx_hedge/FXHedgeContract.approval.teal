#pragma version 10
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 10000 0
    bytecblock 0x151f7c75
    // smart_contracts/fx_hedge/contract.py:7
    // class FXHedgeContract(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@11
    pushbytess 0xd6485718 0x13713205 0x49fe2c46 0x08c77219 0x7a4e70a3 0x6984ee1f // method "create_contract(uint64,uint64,uint64,uint64)string", method "calculate_premium(uint64,uint64)uint64", method "simulate_settlement(uint64,uint64,uint64)string", method "calculate_payout(uint64,uint64,uint64)uint64", method "get_contract_summary(uint64,uint64,uint64,uint64)string", method "convert_rate_to_decimal(uint64)uint64"
    txna ApplicationArgs 0
    match main_create_contract_route@3 main_calculate_premium_route@4 main_simulate_settlement_route@5 main_calculate_payout_route@6 main_get_contract_summary_route@7 main_convert_rate_to_decimal_route@8

main_after_if_else@15:
    // smart_contracts/fx_hedge/contract.py:7
    // class FXHedgeContract(ARC4Contract):
    intc_2 // 0
    return

main_convert_rate_to_decimal_route@8:
    // smart_contracts/fx_hedge/contract.py:90
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/fx_hedge/contract.py:7
    // class FXHedgeContract(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/fx_hedge/contract.py:90
    // @abimethod()
    callsub convert_rate_to_decimal
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_contract_summary_route@7:
    // smart_contracts/fx_hedge/contract.py:78
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c750028436f6e74726163742073756d6d6172792063616c63756c61746564207375636365737366756c6c79
    log
    intc_0 // 1
    return

main_calculate_payout_route@6:
    // smart_contracts/fx_hedge/contract.py:59
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/fx_hedge/contract.py:7
    // class FXHedgeContract(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/fx_hedge/contract.py:59
    // @abimethod()
    callsub calculate_payout
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_simulate_settlement_route@5:
    // smart_contracts/fx_hedge/contract.py:41
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/fx_hedge/contract.py:7
    // class FXHedgeContract(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/fx_hedge/contract.py:41
    // @abimethod()
    callsub simulate_settlement
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_calculate_premium_route@4:
    // smart_contracts/fx_hedge/contract.py:33
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/fx_hedge/contract.py:7
    // class FXHedgeContract(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/fx_hedge/contract.py:33
    // @abimethod()
    callsub calculate_premium
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_create_contract_route@3:
    // smart_contracts/fx_hedge/contract.py:9
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/fx_hedge/contract.py:7
    // class FXHedgeContract(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/fx_hedge/contract.py:9
    // @abimethod()
    callsub create_contract
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@11:
    // smart_contracts/fx_hedge/contract.py:7
    // class FXHedgeContract(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@15
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts.fx_hedge.contract.FXHedgeContract.create_contract(baseline_rate: uint64, target_rate: uint64, notional_amount: uint64, duration_days: uint64) -> bytes:
create_contract:
    // smart_contracts/fx_hedge/contract.py:9-16
    // @abimethod()
    // def create_contract(
    //     self,
    //     baseline_rate: UInt64,  # Rate with 4 decimal places (e.g., 185000 for 18.5000)
    //     target_rate: UInt64,    # Rate with 4 decimal places (e.g., 190000 for 19.0000)
    //     notional_amount: UInt64,  # Amount in micro-units (e.g., 100000000 for $100)
    //     duration_days: UInt64
    // ) -> String:
    proto 4 1
    // smart_contracts/fx_hedge/contract.py:18-19
    // # Validate inputs
    // assert baseline_rate > 0, "Baseline rate must be positive"
    frame_dig -4
    assert // Baseline rate must be positive
    // smart_contracts/fx_hedge/contract.py:20
    // assert target_rate > 0, "Target rate must be positive"
    frame_dig -3
    assert // Target rate must be positive
    // smart_contracts/fx_hedge/contract.py:21
    // assert notional_amount > 0, "Notional amount must be positive"
    frame_dig -2
    assert // Notional amount must be positive
    // smart_contracts/fx_hedge/contract.py:22
    // assert duration_days > 0, "Duration must be positive"
    frame_dig -1
    assert // Duration must be positive
    // smart_contracts/fx_hedge/contract.py:31
    // return String("Contract created successfully")
    pushbytes "Contract created successfully"
    retsub


// smart_contracts.fx_hedge.contract.FXHedgeContract.calculate_premium(notional_amount: uint64, baseline_rate: uint64) -> uint64:
calculate_premium:
    // smart_contracts/fx_hedge/contract.py:33-34
    // @abimethod()
    // def calculate_premium(self, notional_amount: UInt64, baseline_rate: UInt64) -> UInt64:
    proto 2 1
    // smart_contracts/fx_hedge/contract.py:36-37
    // # Convert USD notional to ZAR using baseline rate
    // notional_in_zar = notional_amount * baseline_rate // RATE_PRECISION
    frame_dig -2
    frame_dig -1
    *
    intc_1 // 10000
    /
    // smart_contracts/fx_hedge/contract.py:38-39
    // # Calculate 3% premium in ZAR
    // return notional_in_zar * 3 // 100
    pushint 3 // 3
    *
    pushint 100 // 100
    /
    retsub


// smart_contracts.fx_hedge.contract.FXHedgeContract.simulate_settlement(target_rate: uint64, actual_rate: uint64, notional_amount: uint64) -> bytes:
simulate_settlement:
    // smart_contracts/fx_hedge/contract.py:41-47
    // @abimethod()
    // def simulate_settlement(
    //     self,
    //     target_rate: UInt64,  # Rate with 4 decimal places
    //     actual_rate: UInt64,  # Rate with 4 decimal places
    //     notional_amount: UInt64
    // ) -> String:
    proto 3 1
    // smart_contracts/fx_hedge/contract.py:49
    // if actual_rate <= target_rate:
    frame_dig -2
    frame_dig -3
    <=
    bz simulate_settlement_else_body@2
    // smart_contracts/fx_hedge/contract.py:50
    // return String("Contract would fail - rate did not improve sufficiently")
    pushbytes "Contract would fail - rate did not improve sufficiently"
    retsub

simulate_settlement_else_body@2:
    // smart_contracts/fx_hedge/contract.py:57
    // return String("Contract would succeed - rate improved as expected")
    pushbytes "Contract would succeed - rate improved as expected"
    retsub


// smart_contracts.fx_hedge.contract.FXHedgeContract.calculate_payout(target_rate: uint64, actual_rate: uint64, notional_amount: uint64) -> uint64:
calculate_payout:
    // smart_contracts/fx_hedge/contract.py:59-65
    // @abimethod()
    // def calculate_payout(
    //     self,
    //     target_rate: UInt64,  # Rate with 4 decimal places
    //     actual_rate: UInt64,  # Rate with 4 decimal places
    //     notional_amount: UInt64
    // ) -> UInt64:
    proto 3 1
    // smart_contracts/fx_hedge/contract.py:67
    // if actual_rate <= target_rate:
    frame_dig -2
    frame_dig -3
    <=
    bz calculate_payout_after_if_else@2
    // smart_contracts/fx_hedge/contract.py:68
    // return UInt64(0)
    intc_2 // 0
    retsub

calculate_payout_after_if_else@2:
    // smart_contracts/fx_hedge/contract.py:70-71
    // # Calculate the benefit from rate improvement
    // rate_improvement = actual_rate - target_rate
    frame_dig -2
    frame_dig -3
    -
    // smart_contracts/fx_hedge/contract.py:72-73
    // # Convert notional to same precision as rates for calculation
    // notional_scaled = notional_amount * RATE_PRECISION
    frame_dig -1
    intc_1 // 10000
    *
    // smart_contracts/fx_hedge/contract.py:74
    // payout = (notional_scaled * rate_improvement) // (target_rate * RATE_PRECISION)
    *
    frame_dig -3
    intc_1 // 10000
    *
    /
    // smart_contracts/fx_hedge/contract.py:76
    // return payout
    retsub


// smart_contracts.fx_hedge.contract.FXHedgeContract.convert_rate_to_decimal(rate_scaled: uint64) -> uint64:
convert_rate_to_decimal:
    // smart_contracts/fx_hedge/contract.py:90-91
    // @abimethod()
    // def convert_rate_to_decimal(self, rate_scaled: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/fx_hedge/contract.py:93-94
    // # This would be used by the frontend to display rates properly
    // return rate_scaled // RATE_PRECISION
    frame_dig -1
    intc_1 // 10000
    /
    retsub
